//Code generated automatically by TMVA for Inference of Model file [LayerNormalization.onnx] at [Tue Oct 11 11:29:15 2022] 

#ifndef TMVA_SOFIE_LAYERNORMALIZATION
#define TMVA_SOFIE_LAYERNORMALIZATION

#include<vector>
#include "TMVA/SOFIE_common.hxx"
#include <fstream>
#include <cmath>

namespace TMVA_SOFIE_LayerNormalization{
struct Session {
std::vector<float> fTensor_B = std::vector<float>(4);
float * tensor_B = fTensor_B.data();
std::vector<float> fTensor_W = std::vector<float>(4);
float * tensor_W = fTensor_W.data();
std::vector<float> fTensor_InvStdDev = std::vector<float>(4);
float * tensor_InvStdDev = fTensor_InvStdDev.data();
std::vector<float> fTensor_Mean = std::vector<float>(4);
float * tensor_Mean = fTensor_Mean.data();
std::vector<float> fTensor_Y = std::vector<float>(12);
float * tensor_Y = fTensor_Y.data();


Session(std::string filename ="") {
   if (filename.empty()) filename = "LayerNormalization.dat";
   std::ifstream f;
   f.open(filename);
   if (!f.is_open()){
      throw std::runtime_error("tmva-sofie failed to open file for input weights");
   }
   std::string tensor_name;
   int length;
   f >> tensor_name >> length;
   if (tensor_name != "tensor_B" ) {
      std::string err_msg = "TMVA-SOFIE failed to read the correct tensor name; expected name is tensor_B , read " + tensor_name;
      throw std::runtime_error(err_msg);
    }
   if (length != 4) {
      std::string err_msg = "TMVA-SOFIE failed to read the correct tensor size; expected size is 4 , read " + std::to_string(length) ;
      throw std::runtime_error(err_msg);
    }
    for (int i =0; i < length; ++i) 
       f >> tensor_B[i];
   f >> tensor_name >> length;
   if (tensor_name != "tensor_W" ) {
      std::string err_msg = "TMVA-SOFIE failed to read the correct tensor name; expected name is tensor_W , read " + tensor_name;
      throw std::runtime_error(err_msg);
    }
   if (length != 4) {
      std::string err_msg = "TMVA-SOFIE failed to read the correct tensor size; expected size is 4 , read " + std::to_string(length) ;
      throw std::runtime_error(err_msg);
    }
    for (int i =0; i < length; ++i) 
       f >> tensor_W[i];
   f.close();
}

std::vector<float> infer(float* tensor_X){
   // Operator op_0
   std::vector<size_t> op_0_InputShape ({3,4});
   // Compute the mean
   for (size_t axis_1 = 0; axis_1 < op_0_InputShape[1]; axis_1++){
      float sum = 0.;
      for (size_t axis_0 = 0; axis_0 < op_0_InputShape[0]; axis_0++){
         sum += tensor_X[axis_0 * 4 + axis_1 * 1];
      }
      tensor_Mean[axis_1 * 1] = sum / float(3);
   }
   std::cout << "Mean = ";
   for (size_t i = 0; i < 4; i++) std::cout << tensor_Mean[i] << " ";
   std::cout << std::endl;
   // Compute the inverse Standard Deviation
   for (size_t axis_1 = 0; axis_1 < op_0_InputShape[1]; axis_1++){
      float sum = 0.;
      for (size_t axis_0 = 0; axis_0 < op_0_InputShape[0]; axis_0++){
         sum += std::pow(tensor_X[axis_0 * 4 + axis_1 * 1] - tensor_Mean[axis_1 * 1], 2);
      }
      tensor_InvStdDev[axis_1 * 1] = 1 / std::sqrt(sum / float(3) + 1e-05);
   }
   std::cout << "1/var = ";
   for (size_t i = 0; i < 4; i++) std::cout << tensor_InvStdDev[i] << " ";
   std::cout << std::endl;

   // set Y = Scale o NormalizedInput + B = Scale o InvStdDev (X - Mean) + B
   for (size_t axis_0 = 0; axis_0 < op_0_InputShape[0]; axis_0++){
      for (size_t axis_1 = 0; axis_1 < op_0_InputShape[1]; axis_1++){
         tensor_Y[axis_0 * 4 + axis_1 * 1] = tensor_W[axis_1 * 1] * tensor_InvStdDev[axis_1 * 1] * (tensor_X[axis_0 * 4 + axis_1 * 1] - tensor_Mean[axis_1 * 1]) + tensor_B[axis_1 * 1];
   }
      }
   std::vector<float> ret (tensor_Y, tensor_Y + 12);
   return ret;
}
};
} //TMVA_SOFIE_LayerNormalization

#endif  // TMVA_SOFIE_LAYERNORMALIZATION
